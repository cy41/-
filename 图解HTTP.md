# 一 基础

## 1 分层

​	应用层，传输层，网络层，数据链路层。

![image-20200204213545589](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200204213545589.png)

​	利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。

​	我们用HTTP举例来说明，首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。

​	接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

​	在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。

​	接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。

![image-20200204213802663](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200204213802663.png)

### 1.1 负责传输的IP协议

​	位于网络层。	

​	在满足各类条件的情况下，将各种数据包传送给对方。

​	最重要的两个条件：

1. IP地址：指明了节点被分配到的地址。（可变），可以和MAC地址进行配对。
2. MAC地址：网卡所属的固定地址。（基本不改变）

​	IP间的通信依赖MAC地址。ARP协议是一种用以解析地址的协议，根据通信方的IP地址可以反查出对应的MAC地址。

​	路由选择：类比快递流程，每个节点只需知道来源与去路，也即无论哪台计算机哪台网络设备均无法全面掌握互联网中的细节。

![image-20200205141219602](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200205141219602.png)

### 1.2 确保可靠性的TCP协议

​	位于传输层，提供字节流服务。

​	字节流服务：将大块数据分割成以**报文段**为单位的数据包进行管理。

​	**TCP协议为了更容易传送大数据才把数据分割，并且TCP协议可以确认数据最终是否送达对方。**

​	三次握手：握手过程使用了TCP的标志：SYN与ACK。

1. 发送端首先发送一个带SYN标志的数据包给对方。
2. 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息
3. 最后，发送端再回传一个带ACK标志的数据包，代表握手结束。

注意：若在握手过程中的某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同数据包。

![image-20200205141824554](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200205141824554.png)

### 1.3 负责域名解析的DNS服务

​	处于应用层。提供域名到IP地址之间的解析服务。

​	![image-20200205142417657](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200205142417657.png)

### 总结：一图了解一次通信过程中各协议发挥的作用

![image-20200205142623187](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200205142623187.png)

## 2 URI与URL

### 2.1 统一资源标识符 URI

​	 由某个协议方案表示的资源的定位标识符。协议方案指资源所使用的协议类型名称（HTTP等）。

​	URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），URL是URI的子集。

#### 1.URI格式

​	表示指定的URI，要使用涵盖全部必要信息的绝对URI，绝对URL及相对URL。

​	相对URL指浏览器中基本URI处指定的URL，如：/image/cy.gif。

​	绝对URI的格式：

![image-20200205161554588](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200205161554588.png)

1. 登录信息（可选）
2. 服务器地址，待访问的服务器地址。
3. 服务器端口号，指定服务器连接的网络端口号（可选）
4. 带层次的文件路径，要访问的资源
5. 查询字符串，（可选）
6. 片段标识符 （可选）

# 二 简单的HTTP协议

​	完成服务器端与客户端之间的通信，可区别哪端是谁。

​	通过请求与响应的交换达成通信。

## 1 请求与响应报文组成

![image-20200210124624793](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210124624793.png)

![image-20200210124722734](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210124722734.png)

## 2 HTTP是一种不保存状态的协议

​	自身不对请求与响应之间的通信状态进行保存。

​	为了实现期望的保存状态功能，引入了Cookie技术。

## 3 请求URI定位资源

​	指定URI的方法

![image-20200210140858673](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210140858673.png)

## 4 告知服务器意图的HTTP方法

1. get 获取资源
2. post 传输实体主体
3. put 传输文件
4. head 获取报文首部  用于确认URI的有效性及资源更新的日期时间等。
5. delete 删除文件   按请求URI删除指定文件
6. options 询问网站对于请求的URI指定的资源trace支持的方法
7. trace 让服务器端将之前的请求通信环回给客户端的方法，可能引发跨站追踪攻击，不常用![image-20200210142041763](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210142041763.png)
8. connect 要求用隧道协议连接代理![image-20200210142210775](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210142210775.png)



![image-20200210142314995](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210142314995.png)

## 5 持久连接节省流量

​	持久连接  只要任一端没有明确提出断开连接，则保持TCP连接状态![image-20200210153310412](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210153310412.png)

​	好处在于减少了TCP连接的重复建立与断开造成的额外开销，减轻了服务器端的负载。同时减少开销的那段时间，使HTTP请求和响应能够更早结束，web页面显示速度提高。

​	持久连接使得多数请求以管线化方式发送称为可能。

![image-20200210153649944](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210153649944.png)

## 6 使用Cookie的状态管理

​	Cookie技术通过在请求和响应中写入Cookie信息来控制客户端的状态。

​	![image-20200210154832263](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210154832263.png)

![image-20200210154851009](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210154851009.png)

![image-20200210155910541](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210155910541.png)

# 三 HTTP报文内的HTTP信息

## 1 HTTP报文

​	用于HTTP协议交互的信息。

​	请求报文与响应报文。

​	HTTP报文大致可分为报文首部与报文主体两块。两者由最初出现的空行分割。通常并不一定要有报文主体。

![image-20200210160557655](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210160557655.png)

报文结构

![image-20200210161830696](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210161830696.png)

![image-20200210161849810](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210161849810.png)

![image-20200210161931029](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210161931029.png)

## 2 编码提高传输效率

​	![image-20200210210446882](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210210446882.png)

​	分割发送的分块传输编码  传送大容量的数据时，通过将数据分割成多块，可以让浏览器逐步显示页面。

![image-20200210210849226](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210210849226.png)

## 3 发送多种数据的多部分对象集合

​	发送的一份报文主体内可含有多类型实体。

​	多部分对象集合包含对象：

● multipart/form-data   在Web表单文件上传时使用。

● multipart/byteranges   状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type

例：

![image-20200210211759817](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210211759817.png)

![image-20200210211816234](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210211816234.png)

![image-20200210211828637](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210211828637.png)





## 4 获取部分内容的范围请求（比如下载到一半的内容断网，再次下载可以接着上一次的）

​	![image-20200210211425134](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210211425134.png)

byte范围：

1. a-b  范围
2. a-  a到之后所有
3. -a   从一开始到a
4. a-b，c-d   多重范围



​	对于范围请求，响应会返回状态码为206 Partial Content的响应报文。对于多重范围请求，则会在首部字段Content-Type标明multipart/byteranges后返回响应报文。

​	若无法响应范围，则返回状态码200 OK和完整的实体内容。

## 5 内容协商

​	指客户端与服务器端就响应内容进行交涉，然后提供给客户端最适合资源，内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

​	包含在请求报文中的某些首部字段就是判断基准，如：

![image-20200210212357416](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200210212357416.png)

​	内容协商技术有：

1. 服务器驱动协商（Server-driven Negotiation）  由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。
2. 客户端驱动协商（Agent-driven Negotiation）  由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。
3. 透明协商（Transparent Negotiation）   是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 四 返回结果的HTTP状态码

![image-20200212165538541](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200212165538541.png)

## 1 2XX 成功

1. 200 OK 
2. 204 No Content  请求处理成功，但无资源返回    一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
3. 206 Partial Content  范围请求成功

## 2 3XX 重定向

1. 301 Moved Permanently  永久性重定向 该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
2. 302 Found  临时性重定向  该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。
3. 303 See Other  执行处理结果后希望客户端以get的方法重定向到另一个URI上去。
4. 304 Not Modified  与重定向无关
5. 307 Temporary Redirect  临时重定向

## 3 4XX 客户端错误

1. 400 Bad Request  请求报文存在语法错误
2. 401 Unauthorized  需要认证
3. 403 Forbidden  服务器拒绝访问该资源
4. 404 Not Found  无被请求资源

## 4 5XX 服务器错误

1. 500 Internal Server Error 
2. 503 Service Unavailable  服务器正停机维护或超负荷

# 五 Web服务器

​	单台虚拟机可以实现多个域名

![image-20200212173953625](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200212173953625.png)

​	当请求发送到服务器端时，经过了域名解析，已经变成了IP地址的形式访问了，故当一台服务器同时托管了多个域名时，接收到请求就必须搞清楚到底访问的是该IP地址下的哪个域名。所有在发送HTTP请求时必须在Host首部完整指定主机名或域名的URI。

## 1 通信数据转发程序：代理、网关、隧道

​	可以将请求转发给通信线路上的下一站服务器，且可以接收从那台服务器发送的响应再转发给客户端。

### 1.1 代理

​	级联多台代理服务器时，转发时需要附加Via首部字段以标记出经过的主机信息。

![image-20200212175954933](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200212175954933.png)

​	好处：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等

​	按照两种基准分类：是否使用缓存，是否会修改报文。

缓存代理：

​	代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。

​	当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

透明代理：

​	转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（TransparentProxy）。反之，对报文内容进行加工的代理被称为非透明代理。

### 1.2 网关

​	可以使通信线路上的服务器提供非HTTP协议服务。![image-20200212193308314](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200212193308314.png)

### 1.3 隧道

​	隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

​	隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

​	![image-20200212193521516](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200212193521516.png)

# 六 HTTP报文首部

## 1 基础

​	结构： 首部字段：字段值

### 1.1 分类

1. 通用首部字段，接收双方都会使用
2. 请求首部字段
3. 响应首部字段
4. 实体首部字段，补充与实体有关的信息

### 1.2 缓存与非缓存代理

​	端到端首部（End-to-end Header）

​	分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

​	逐跳首部（Hop-by-hop Header）

​	分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。

## 2 通用首部字段

​	

# 七 HTTPS

HTTP的缺点：

1. 通信使用明文（不加密），内容可能会被窃听
2. 不验证通信方身份，有可能遭遇伪装（dos攻击拒绝服务攻击）
3. 无法证明报文完整性，有可能已被篡改（中间人攻击）

通信的加密：HTTP+SSL=HTTPS，用SSL建立安全通信线路，就可以在这条线路上进行HTTP通信了。超文本传输安全协议

内容的加密：将HTTP报文信息进行加密处理（报文主体的内容）。

![image-20200226183208541](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200226183208541.png)

![image-20200226183243896](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200226183243896.png)





# web攻击

1. 主动攻击，攻击者直接访问web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。
2. 以服务器为目标被动攻击，![image-20200226191734442](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200226191734442.png)
3. 利用用户身份攻击内部网络![image-20200226191831548](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200226191831548.png)

# TCP协议

![image-20200324192416501](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200324192416501.png)

![image-20200227200352117](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200227200352117.png)

## 1.如何保证可靠传输

1. 应用数据被分割成TCP认为最适合发送的数据块。

2. 对失序数据包排序，将发送包编号，接收方按顺序排序后，将有序数据发往应用层。

3. 校验和，发送的数据包的二进制相加取反，**目的是检测数据在传输过程中的任何变化**。若收到段的校验和有差错，**则将丢弃该数据包且不确认接收此数据包。**

4. 确认应答+序列号（累积确认+seq），接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）。每次接受方收到数据后，都会发送ACK报文回去，ACK报文中带有对应的确认序列号，接受了哪些数据，下一次发送应该从哪个位置开始发送。

5. 超时重传，当TCP发出一个段后，启动计时器，若不能及时收到确认收到，则重发该段。超时以0.5秒为一个单位进行控制，每次判定超时时间都是0.5秒的整数倍，该判定时间以指数增长，**累积到一定重传次数后，TCP就认定网络或者对端出现问题，强制关闭连接。**

6. 流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP的**接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。若接收到的窗口大小为0，则发送方停止发数据，并**定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。** 

7. 接收端会丢弃重复的数据。

8. 拥塞控制，当网络拥塞时，减少数据的发送，发送方有拥塞窗口，发送数据前比对接收方发送来的即使窗口大小进行调整。**为了降低整个网络的拥塞程度。**

    TCP 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复。**

    前两个均是发送端未检测到拥塞时采用的积极避免拥塞的方式，后两个是实际发生拥塞时采用的方式，引发拥塞的依据：传输超时，接收到重复的确认报文段。
    
    1. 慢开始，由小到大增大拥塞窗口大小，按指数增长，不断*2。
    
    2. 拥塞避免，按线性增长拥塞窗口大小。
    
    3. 快速重传，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
    
    4. 快速恢复，
    
        1.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
    
        2.考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。
    
    ![image-20200229214942740](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200229214942740.png)
    
    

## 2. 三次握手

采用三报文握手主要是**为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。**

1. A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，**表明传送数据时的第一个数据字节的序号是 x。**
2. B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B **在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x+1，自己选择的序号 seq = y。**
3. A 收到此报文段后向 B 给出确认，**其 ACK = 1，确认号 ack = y + 1。A 的 TCP 通知上层应用进程，连接已经建立。**
4. **B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立**。

![image-20200227200459822](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200227200459822.png)

## 3. 四次挥手

​	中断连接端可以是客户端，也可以是服务器端。

1.第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

2.第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请你继续等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

3.第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

4.第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

![image-20200227201828359](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200227201828359.png)



# UDP协议

![image-20200227181937696](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200227181937696.png)

## TCP与UDP的异同

1. UDP无连接，时间上不存在建立连接需要的时延，TCP需要在端系统中**维护连接**状态，UDP不维护连接状态。
2. 分组首部开销小，TCP首部20字节，UDP8字节
3. UDP没有拥塞控制，应用于某些允许部分数据丢失，但不允许时延的场景（直播）
4. UDP面向报文，报文为最小单位，不合并，不拆分。

# OSI七层与TCP/IP五层

​	![image-20200228111322051](%E5%9B%BE%E8%A7%A3HTTP.assets/image-20200228111322051.png)

1. 物理层，利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
2. 数据链路层，接收来自物理层的位流形式的数据，封装成帧传送至网络层；同时也接收网络层的数据帧拆成位流形式数据发往物理层。
3. 网络层，提供逻辑地址（IP）、选路，数据从源端到目的端的传输。
4. 传输层，是通信子网与资源子网的接口与桥梁，起到承上启下的作用，向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。提供传输连接管理，处理传输差错，监控服务质量。
5. 会话层，组织协调两个会话进程之间的通信，并对数据交换进行管理。
6. 表示层，处理用户信息的表示问题，如编码、数据格式转换和加密解密。
7. 应用层，确定进程之间通信的性质以满足用户需要以及提供网络与用户应用。

