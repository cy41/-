# 一、第一章

## 1.操作系统的基本特性

1. 并发
2. 共享
3. 虚拟
4. 异步

## 2.操作系统的主要功能

- 处理机管理
- 存储器管理
- 设备管理
- 文件管理
- 用户接口

# 二、第二章

## 1.程序并发执行

### 1.特征

1. 间断性
2. 失去封闭性
3. 不可再现性

## 2.进程的描述

### 1.定义

1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位
4. 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

进程实体：程序+数据+进程控制块（PCB）

### 2.进程与程序的主要区别

|            | 程序     | 进程                |
| ---------- | -------- | ------------------- |
| 概念       | 静态     | 动态                |
| 所在存储器 | 外存     | 内存                |
| 存在时间   | 永久     | 有生命期            |
| 组成       | 有序指令 | 程序段，数据段，PCB |
| 对应关系   | 一个多   | 一对多              |

### 3.进程状态转换总图

![1575510625115](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/1575510625115.jpeg)

### 4.进程管理中的数据结构

OS管理的数据结构一般分为四类：

1. 内存表
2. 设备表
3. 文件表
4. 进程表（PCB）

#### 4.1 PCB的作用

记录了系统管理进程所需的全部信息，系统根据PCB的存在而感知进程的存在，PCB是进程存在的唯一标志。PCB常驻内存。

1. 作为独立运行基本单位的标志
2. 能实现间断性运行方式
3. 提供进程管理所需要的信息
4. 提供进程调度所需要的信息
5. 实现与其他进程的同步与通信

#### 4.2 PCB中的信息

1. 进程标识符   外部标识符（用户使用），内部标识符（系统使用）
2. 处理机状态  由处理机的各种寄存器中的内容组成
3. 进程调度信息，进程状态，进程优先级，进程调度所需的其它信息，阻塞原因
4. 进程控制信息，程序和数据的地址，进程同步和通信机制，资源清单，链接指针

## 5.进程控制

进程控制是进程管理中最基本的功能，即对系统中所有的进程实施有效的管理，其功能包括**进程的创建，撤销，阻塞与唤醒**等，这些功能一般是**由操作系统的内核中的原语来实现的**。

### 5.1 操作系统内核的功能

1. 支撑功能：中断处理，时钟管理，原语操作
2. 资源管理功能：进程管理，存储器管理，设备管理

所谓原语：由若干条指令组成，用于完成一定功能的一个过程。

### 5.2 进程的创建

#### 5.2.1 引起创建进程的事件

用户登录，作业调度，提供服务，应用请求

#### 5.2.2 进程的创建

1. 申请空白PCB
2. 为新进程分配其运行所需的资源
3. 初始化进程控制块PCB
4. 若进程就绪队列能接纳新进程，则将新进程插入就绪队列

### 5.3 进程同步的基本概念

#### 5.3.1 两种形式的制约关系

系统中诸进程之间在逻辑上存在着两种制约关系：

- 直接制约关系（进程同步）：即为完成同一个任务的诸进程间，因需要协调它们的工作而相互等待、相互交换信息所产生的直接制约关系。这种制约主要源于进程间的合作。
- 间接制约关系（进程互斥）：是进程共享独占型资源而必须互斥执行的间接制约关系。

| 直接制约关系                                   | 间接制约关系                       |
| ---------------------------------------------- | ---------------------------------- |
| 进程-进程                                      | 进程-资源-进程                     |
| 时间次序上受到某种限制                         | 竞争到某一物理资源时不允许进程工作 |
| 相互清楚对方的存在及作用，交换信息             | 不一定清楚其进程情况               |
| 往往指有几个进程共同完成一个任务               | 往往指多个任务多个进程间通讯制约   |
| 例：生产与消费之间，发送与接收之间，作者与读者 | 交通十字路口，单轨火车的拔道岔     |

![image-20191207095102441](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207095102441.png)



#### 5.3.2 临界资源、临界区

- 临界资源：**一次只允许一个进程使用的资源称为临界资源。**入打印机，绘图机；变量，数据等，诸进程间**采取互斥方式**实现对这种临界资源的共享，从而实现并行程序的封闭性。

每个进程中访问临界资源的那段代码称为临界区。

#### 5.3.3 同步机制应遵循的规则

- 有空让进（空闲让进）
- 互斥（忙则等待）
- 有限等待
- 让权等待

### 5.4 进程与线程的比较

- 进程是资源分配单位，线程是CPU调度单位
- 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
- 线程具有就绪，等待，运行三种基本状态和状态间的转换关系
- 线程能减少并发执行的时间和空间开销：线程的创建，终止时间比进程短，同一进程内的线程切换比进程短，由于同一进程中的各线程共享内存和文件资源，可不通过内核进行直接通信
- 进程能并发执行，提高资源利用率和系统吞吐量；线程提高并发执行的程度，减小开销，进一步提高资源的利用率和系统吞吐量。





### 5.5 三对原语

1. 进程的创建与终止 create
2. 进程的挂起与激活 suspend active
3. 进程的阻塞与唤醒 block wakeup

### 5.6 用户级线程与内核级线程

|              | 用户级线程                                           | 内核级线程                                                   |
| ------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 管理         | 线程库                                               | 内核                                                         |
| 调度单位     | 进程                                                 | 线程                                                         |
| 切换速度     | 同一进程诸线程间切换，由线程库完成，速度较快         | 由内核完成，速度较慢                                         |
| 系统调用行为 | 内核看作是整个用户进程的行为                         | 内核只看作该线程的行为                                       |
| 阻塞         | 用户进程                                             | 线程                                                         |
| 优点         | 线程切换不调用内核，切换较快，调度算法可由应用程序定 | 对多对处理器，可同时调度同一进程的多个线程，速度较快；阻塞是在线程一级 |
| 缺点         | 阻塞在用户进程一级                                   | 同一进程内的线程切换速度慢                                   |



## 6. 信号量机制

整型信号量，记录型信号量。S为变量。

### 1. 整型信号量

一对原语：wait(S),signal(S) 可以将wait和signal理解为函数，S为信号量，对应P,V操作。

整型信号量不满足“让权等待”原则，会发生“忙等”。

![image-20191207121703262](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207121703262.png)



### 2. 记录型信号量

![image-20191207121811239](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207121811239.png)

可以用记录型信号量实现系统资源的“申请”和“释放”。

### 补充 信号量集的几种特殊情况：

1. Swait（S,d,d）。此时选择信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
2. Swait（S,1,1）。此时的信号量集已蜕化为一般的记录型信号量（S>1时）或互斥信号量（S=1时）。
3. Swait（S,1,0）。这是一种很特殊且有很有用的信号量操作。当S>=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。



### 3. 用信号量机制实现进程互斥，同步，进程的前驱关系

#### 3.1 实现互斥

1. 设置互斥信号量为1即可
2. 在临界区之前执行P操作
3. 在临界区之后执行V操作

#### 3.2 实现同步

![image-20191207124621190](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207124621190.png)

#### 3.3 实现前驱关系

![image-20191207125025032](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207125025032.png)

### 4. 生产者消费者问题

生产者和消费者共享一个缓冲区，生产者进程生产产品放入缓冲区，消费者进程从缓冲区取产品使用。

只有缓冲区没满的时候，生产者才能将产品放入缓冲区，否则等待。

只有缓冲区有产品时，消费者才能取产品，否则等待。

缓冲区必须是互斥的访问。

关系分析：

1. 各进程必须互斥地访问，互斥
2. 缓冲区满，生产者需要等消费者取走产品，同步关系
3. 缓冲区空，消费者需要等生产者生产产品，同步关系

即，生产者需要每次**消耗一个缓冲区（P操作）**，并**生产一个产品（V操作）**。

​		消费者每次**消耗一个产品（P操作）**，并**释放一个空闲缓冲区（V操作）**。

​		往缓冲区放入/取出产品需要互斥。

PV题目步骤

1. 分析关系
2. 整理思路
3. 设置信号量

semphore mutex =1；//互斥信号量，实现对缓冲区的互斥

semphore empty =0；//同步信号量，表示空闲缓冲区的数量

semphore full =0；//同步信号量，表示产品数量，也即非空缓冲区的数量

实现互斥的P操作一定要在实现同步的P操作之后。

V操作不会导致进程阻塞，故两个V操作的顺序可以交换。

```cpp
producer (){
	while(1){
        P(empty)
        P(mutex)
        将产品放入缓冲区
        V(mutex)
        V(full)
    }
}

consumer (){
    while(1){
        P(full)
        P(mutex)
        取产品
        V(mutex)
        V(empty)
        使用产品
    }
}

```

### 5. 多生产者多消费者

多类生产者和多类消费者。

若缓冲区大于1，则需要专门设置一个互斥信号量来实现对缓冲区的互斥访问，若不设置，则可能会发生两个消费者进程同时向临界区插入数据，可能会造成数据覆盖。

### 6. 吸烟者问题

![image-20191207161527914](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207161527914.png)

解决生产多个产品的单生产者问题。

### 7. 读者-写者问题

1. 运行多个读者进行同时进行读操作
2. 只运行一个写者往文件写数据
3. 任一写者在完成写操作前不允许其他读者写者工作
4. 写者执行写操作前，应让已有的读者和写者全部退出

### 8. 哲学家进餐问题

![image-20191207191836870](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207191836870.png)

![image-20191207193023528](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207193023528.png)

## 7. 管程





# 第三章

## 1. 调度算法

**目的**

1. 资源利用率
2. 公平性
3. 平衡性
4. 策略强制执行



周转时间=完成时间-到达时间

带权周转时间=周转时间/运行时间

等待时间=周转时间-运行时间-I/O操作的时间

1. 先来先服务，队列式的服务

2. 短作业优先，非抢占式：**当前已到达的且运行时间最短的**；抢占式：当有进程进入就绪队列就需要调度，若新到达的进程剩余时间比当前运行进程的时间更短，则新进程抢占处理机，当前进程进入就绪队列。

3. 高响应比优先，**响应比的计算方式：（等待时间+要求服务时间）/要求服务时间**。非抢占式。

4. 时间片轮转，使用时间片调度算法，进程依次使用**时间片大小**的处理机，然后若有新的进程进入就绪队列，则上处理机；**需要注意的是，当一个进程的运行时间没有达到时间片大小的时候，它会在运行完便主动放弃处理机**。

5. 优先级调度算法，每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。**非抢占式：**每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。**抢占式：**每次调度时**选择当前已到达**且优先级最高的进程。当前进程**主动放弃处理机时**发生调度。另外，当**就绪队列发生改变时**也需要检查是否会发生抢占。

6. 多级反馈队列调度算法，![image-20191207092939040](C:\Users\11979\Desktop\markdown文档\操作系统学习.assets\image-20191207092939040.png)

    ![image-20191207093928173](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207093928173.png)

    7.EDF算法（最早截止时间优先算法）

    根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机。即可用于抢占式也可用于非抢占式。

    8.LLF算法（最低松弛度优先算法）
    
    该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度越高，赋予该任务的优先级就越高，使之优先执行。主要应用于可抢占式方式。紧急程度=指定完成时间-运行时间。紧急程度低的排在就绪队列的队头。
    
    
    
    
    
    
    
    
    
    ## 2. 死锁
    
    ### 2.1 死锁，饥饿，死循环的区别
    
    死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
    
    饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。
    
    死循环：某进程执行过程中一直跳不出某个循环的现象。
    
    ### 2.2 死锁产生的必要条件
    
    必须同时满足以下四个条件才会产生死锁
    
    1. 互斥条件：只有对必须互斥使用的资源的争夺才会导致死锁。
    2. 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
    3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保存不放。
    4. 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
    
    ### 2.3 什么时候会发生死锁
    
    ![image-20191207202214966](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207202214966.png)
    
    ### 2.4 死锁的处理策略
    
    1. 预防死锁
    2. 避免死锁
    3. 死锁的检测与解除
    
    #### 2.4.1 预防死锁
    
    #### 2.4.2 避免死锁
    
    ![image-20191207213404234](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207213404234.png)
    
    ![image-20191207213511083](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207213511083.png)
    
    **银行家算法**
    
    在分配资源之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。
    
    ![image-20191207215551122](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191207215551122.png)
    
    #### 2.4.3 死锁的检测与解除
    
    ![image-20191208104632162](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208104632162.png)
    
    ![image-20191208105024945](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208105024945.png)
    
    ![image-20191208105231041](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208105231041.png)
    
    ![image-20191208105326222](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208105326222.png)
    
    
    
    

# 第四章

## 1. 内存管理

需要管理的事项：

1. 内存空间的分配与回收
2. 内存空间的扩展（虚拟技术）
3. 地址转换（逻辑到物理的重定位）现代一般采用动态运行时装入的方式
4. 内存保护，让各进程只能访问自己的内存空间。

1.抽象，逻辑地址空间

2.保护，独立地址空间

3.共享，访问相同内存

4.虚拟化，更大的地址空间

### 1.1 内存空间的扩充

覆盖技术，交换技术，虚拟存储技术。

1.覆盖技术：用来解决程序大小总和超过物理内存总和的问题。将程序分段，常用的常驻内存，不常用的调用时调入内存。将内存区分为 固定区与覆盖区。

![image-20191208153507459](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208153507459.png)

![image-20191208153548173](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191208153548173.png)

2.交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存某些已具备运行条件的进程换入内存

（进程在内存与磁盘间动态调度）。

3.虚拟存储技术：

1. 多次性：无需在作业运行时一次性全部转入内存
2. 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入，换出。
3. 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量。

实现需要建立在离散分配内存方式的基础之上。

![image-20191209190442150](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209190442150.png)

覆盖与交换的区别：覆盖是在一个进程或程序中进行的，交换是在多个不同进程间进行的。



### 1.1.2 内存空间的分配与回收

1. 连续分配管理方式：单一连续分配，固定分区分配，动态分区分配。
2. 非连续。



## 2.操作系统采用的内存管理方式

1.重定位

2.分段

3.分页

4.虚拟存储

## 3.逻辑地址生成

编译->汇编->链接->程序加载（重定位）

## 4.连续内存分配：动态分区分配

### 4.1 动态分区分配

- 当程序被加载执行时，分配一个进程指定大小的可变的分区（块，内存块）
- 分区的地址是连续的

### 4.2 操作系统需要维护的数据结构

- 所有进程的已分配分区
- 空闲分区

### 4.3 动态分区分配策略

- 最先匹配，空闲分区列表按地址顺序排序，从前往后找到第一个合适的分区；释放时，检查是否可与临近的空闲分区合并。
- 最佳匹配，比他大的最小的分区；释放时同上。
- 最差匹配，找比他大的最大的分区。
- 邻近适应算法，最先匹配基础上，每次从上一次查找结束的位置开始检索，找到能满足的第一个。

### 4.4 内存分配与回收

1. 分配：
    1. 若分配给的是一个较大空闲区的较小部分，则在空闲分区表中修改分区大小及起始位置
    2. 若分配给的是正好的，则空闲分区表中的空闲分区数量减一
2. 回收：空闲相邻进程合并为一个，若前后都无相邻的则新增一个空闲分区。

动态分区分配没有内部碎片，但有外部碎片。

![image-20191209100949424](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209100949424.png)

## 5. 非连续分配方式（离散）

- 基本分页式
- 基本分段式
- 段页式

### 5.1 基本分页式

思想：把内存分为一个个相等的小分区，再按照小分区大小将进程拆分为一个个小部分。

小分区：页框，页帧，物理块。

给每一个页帧编号。

#### 5.1.1 逻辑地址->物理地址



![image-20191209103717124](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209103717124.png)

页号=逻辑地址/页面长度

页内偏移量=逻辑地址%页面长度

页面起始位置：操作系统的某种数据结构会记录

![image-20191209104254050](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209104254050.png)

页表：

为了能知道进程的每个页面在内存中存放的位置，操作系统为每个进程建立一个页表

![image-20191209104424279](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209104424279.png)



页号：逻辑。块号：物理。

进程的某表项在页表中的位置=页表起始地址+页号*页表项长度。

然后可以知道块号

接下来 块号*页面大小+页内偏移量=物理地址。

![image-20191209142039535](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209142039535.png)

#### 5.1.2 两级页表

多级页表中各级页表的大小不能超过一个页面，多级页表访问内存次数为n+1次（没有快表的机制下）

### 5.2 基本分段式

以段为单位进行分配，每个段在内存中占据连续的空间，但各段之间可以不相邻。

逻辑地址结构：段号+段内地址

段表：与页表差不多。每个段表由段号，段长，基址组成。**段表项长度是相同的**，	

![image-20191209170802680](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209170802680.png)

**分段与分页的区别**

1. 在分页中每个页面的长度是相同的，分段中是不同的，在分页中并不需要对段内地址做越界检查，而分段需要。
2. 页是信息的物理单位，段是信息的逻辑单位
3. 分页的主要目的是为了实现离散分配，提高内存利用率。分段是更好地满足用户需求
4. 分页是系统管理上的需要，对用户不可见。分段对用户可见，用户编程时需要显式的给出段名。
5. 页的大小是固定且由系统决定的，段的长度不固定，决定于用户
6. 分页的地址空间是一维的，分段是二维的，用户在标识一个地址时，既要给出段名，也要给出段内地址
7. 分段比分页更容易实现信息的共享和保护

### 5.3 段页式

将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相等的物理块。

段号，页号，页内偏移量

![image-20191209182316457](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0.assets/image-20191209182316457.png)

段表：存放页面长度，页表存放的块号。

页表：页号，物理块号。

段号与页号都可以是隐含的。

